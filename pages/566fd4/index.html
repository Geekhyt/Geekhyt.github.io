<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Vue面试题整理 | 童欧巴博客</title>
    <meta name="generator" content="VuePress 1.5.2">
    <link rel="icon" href="/img/favicon.ico">
    <meta name="description" content="web前端技术博客,简洁至上,专注web前端学习与总结。JavaScript,js,ES6,TypeScript,vue,python,css3,html5,Node,git,github等技术文章。">
    <meta name="keywords" content="前端博客,个人技术博客,前端,前端开发,前端框架,web前端,前端面试题,技术文档,学习,面试,JavaScript,js,ES6,TypeScript,vue,python,css3,html5,Node,git,github,markdown">
    <meta name="baidu-site-verification" content="code-1xXsjR4O7D">
    <meta name="theme-color" content="#11a8cd">
    <link rel="preload" href="/assets/css/0.styles.5d660632.css" as="style"><link rel="preload" href="/assets/js/app.e6110941.js" as="script"><link rel="preload" href="/assets/js/2.d5df4bac.js" as="script"><link rel="preload" href="/assets/js/3.91f688ac.js" as="script"><link rel="preload" href="/assets/js/62.ad006f4a.js" as="script"><link rel="prefetch" href="/assets/js/10.3199ebec.js"><link rel="prefetch" href="/assets/js/11.23fcadef.js"><link rel="prefetch" href="/assets/js/12.c0606614.js"><link rel="prefetch" href="/assets/js/13.f31dd943.js"><link rel="prefetch" href="/assets/js/14.b62224fa.js"><link rel="prefetch" href="/assets/js/15.12d722d0.js"><link rel="prefetch" href="/assets/js/16.c18c577a.js"><link rel="prefetch" href="/assets/js/17.33db1aff.js"><link rel="prefetch" href="/assets/js/18.2169539d.js"><link rel="prefetch" href="/assets/js/19.80147783.js"><link rel="prefetch" href="/assets/js/20.750d5116.js"><link rel="prefetch" href="/assets/js/21.fd13e0c4.js"><link rel="prefetch" href="/assets/js/22.c2229ed4.js"><link rel="prefetch" href="/assets/js/23.2dffd82d.js"><link rel="prefetch" href="/assets/js/24.ed95c331.js"><link rel="prefetch" href="/assets/js/25.273f6808.js"><link rel="prefetch" href="/assets/js/26.f81c2466.js"><link rel="prefetch" href="/assets/js/27.ed1fa402.js"><link rel="prefetch" href="/assets/js/28.86bddcec.js"><link rel="prefetch" href="/assets/js/29.acb6ba1d.js"><link rel="prefetch" href="/assets/js/30.085db3bb.js"><link rel="prefetch" href="/assets/js/31.10a4a0ad.js"><link rel="prefetch" href="/assets/js/32.dab0f919.js"><link rel="prefetch" href="/assets/js/33.ff4e525c.js"><link rel="prefetch" href="/assets/js/34.4972fdf0.js"><link rel="prefetch" href="/assets/js/35.8eef4f2e.js"><link rel="prefetch" href="/assets/js/36.12e3a40e.js"><link rel="prefetch" href="/assets/js/37.1d8cac74.js"><link rel="prefetch" href="/assets/js/38.1b9d84f3.js"><link rel="prefetch" href="/assets/js/39.8da043e8.js"><link rel="prefetch" href="/assets/js/4.f0bed083.js"><link rel="prefetch" href="/assets/js/40.cad56f3f.js"><link rel="prefetch" href="/assets/js/41.078ff48e.js"><link rel="prefetch" href="/assets/js/42.ccab846c.js"><link rel="prefetch" href="/assets/js/43.505c53c7.js"><link rel="prefetch" href="/assets/js/44.cd659556.js"><link rel="prefetch" href="/assets/js/45.14dd0e87.js"><link rel="prefetch" href="/assets/js/46.1839d303.js"><link rel="prefetch" href="/assets/js/47.b210acd4.js"><link rel="prefetch" href="/assets/js/48.5748de13.js"><link rel="prefetch" href="/assets/js/49.0855ea96.js"><link rel="prefetch" href="/assets/js/5.3325315f.js"><link rel="prefetch" href="/assets/js/50.ec32b7d5.js"><link rel="prefetch" href="/assets/js/51.2bbf040f.js"><link rel="prefetch" href="/assets/js/52.3305d4e2.js"><link rel="prefetch" href="/assets/js/53.5ddbb2ed.js"><link rel="prefetch" href="/assets/js/54.66fb0ed1.js"><link rel="prefetch" href="/assets/js/55.502aea49.js"><link rel="prefetch" href="/assets/js/56.b8d4f0b6.js"><link rel="prefetch" href="/assets/js/57.631c9b6f.js"><link rel="prefetch" href="/assets/js/58.de68c1bb.js"><link rel="prefetch" href="/assets/js/59.a8e3322d.js"><link rel="prefetch" href="/assets/js/6.e60bc4f1.js"><link rel="prefetch" href="/assets/js/60.405df580.js"><link rel="prefetch" href="/assets/js/61.b8c9ede6.js"><link rel="prefetch" href="/assets/js/63.3a8cad4b.js"><link rel="prefetch" href="/assets/js/64.7f3316c4.js"><link rel="prefetch" href="/assets/js/65.baee1c39.js"><link rel="prefetch" href="/assets/js/66.726c4408.js"><link rel="prefetch" href="/assets/js/67.03b35a22.js"><link rel="prefetch" href="/assets/js/7.a139d7a8.js"><link rel="prefetch" href="/assets/js/8.bb4f29c6.js"><link rel="prefetch" href="/assets/js/9.7d18e657.js">
    <link rel="stylesheet" href="/assets/css/0.styles.5d660632.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open have-rightmenu"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/img/avatar.jpeg" alt="童欧巴博客" class="logo"> <span class="site-name can-hide">童欧巴博客</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><a href="/categories/" class="nav-link">分类</a></div><div class="nav-item"><a href="/tags/" class="nav-link">标签</a></div><div class="nav-item"><a href="/archives/" class="nav-link">归档</a></div><div class="nav-item"><a href="/about/" class="nav-link">关于</a></div><div class="nav-item"><a href="/friends/" class="nav-link">友情链接</a></div> <a href="https://github.com/Geekhyt" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar" style="display:none;"><div class="blogger"><img src="http://hungryturbo.gitee.io/webcanteen/images/avatar.jpeg"> <div class="blogger-info"><h3>童欧巴</h3> <span>公众号【前端食堂】主理人</span></div></div> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><a href="/categories/" class="nav-link">分类</a></div><div class="nav-item"><a href="/tags/" class="nav-link">标签</a></div><div class="nav-item"><a href="/archives/" class="nav-link">归档</a></div><div class="nav-item"><a href="/about/" class="nav-link">关于</a></div><div class="nav-item"><a href="/friends/" class="nav-link">友情链接</a></div> <a href="https://github.com/Geekhyt" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><a href="/pages/566fd4/" aria-current="page" class="active sidebar-link">Vue面试题整理</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/566fd4/#_0-那你能讲一讲mvvm吗？" class="sidebar-link">0.那你能讲一讲MVVM吗？</a></li><li class="sidebar-sub-header"><a href="/pages/566fd4/#_1-简单说一下vue2-x响应式数据原理" class="sidebar-link">1.简单说一下Vue2.x响应式数据原理</a></li><li class="sidebar-sub-header"><a href="/pages/566fd4/#_2-那你知道vue3-x响应式数据原理吗？" class="sidebar-link">2.那你知道Vue3.x响应式数据原理吗？</a></li><li class="sidebar-sub-header"><a href="/pages/566fd4/#_3-再说一下vue2-x中如何监测数组变化" class="sidebar-link">3.再说一下vue2.x中如何监测数组变化</a></li><li class="sidebar-sub-header"><a href="/pages/566fd4/#_4-nexttick知道吗，实现原理是什么？" class="sidebar-link">4.nextTick知道吗，实现原理是什么？</a></li><li class="sidebar-sub-header"><a href="/pages/566fd4/#_5-说一下vue的生命周期" class="sidebar-link">5.说一下Vue的生命周期</a></li><li class="sidebar-sub-header"><a href="/pages/566fd4/#_6-你的接口请求一般放在哪个生命周期中？" class="sidebar-link">6.你的接口请求一般放在哪个生命周期中？</a></li><li class="sidebar-sub-header"><a href="/pages/566fd4/#_7-再说一下computed和watch" class="sidebar-link">7.再说一下Computed和Watch</a></li><li class="sidebar-sub-header"><a href="/pages/566fd4/#_8-说一下v-if和v-show的区别" class="sidebar-link">8.说一下v-if和v-show的区别</a></li><li class="sidebar-sub-header"><a href="/pages/566fd4/#_9-组件中的data为什么是一个函数？" class="sidebar-link">9.组件中的data为什么是一个函数？</a></li><li class="sidebar-sub-header"><a href="/pages/566fd4/#_10-说一下v-model的原理" class="sidebar-link">10.说一下v-model的原理</a></li><li class="sidebar-sub-header"><a href="/pages/566fd4/#_11-vue事件绑定原理说一下" class="sidebar-link">11.Vue事件绑定原理说一下</a></li><li class="sidebar-sub-header"><a href="/pages/566fd4/#_12-vue模版编译原理知道吗，能简单说一下吗？" class="sidebar-link">12.Vue模版编译原理知道吗，能简单说一下吗？</a></li><li class="sidebar-sub-header"><a href="/pages/566fd4/#_13-vue2-x和vue3-x渲染器的diff算法分别说一下" class="sidebar-link">13.Vue2.x和Vue3.x渲染器的diff算法分别说一下</a></li><li class="sidebar-sub-header"><a href="/pages/566fd4/#_14-再说一下虚拟dom以及key属性的作用" class="sidebar-link">14.再说一下虚拟Dom以及key属性的作用</a></li><li class="sidebar-sub-header"><a href="/pages/566fd4/#_15-keep-alive了解吗" class="sidebar-link">15.keep-alive了解吗</a></li><li class="sidebar-sub-header"><a href="/pages/566fd4/#_16-vue中组件生命周期调用顺序说一下" class="sidebar-link">16.Vue中组件生命周期调用顺序说一下</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/566fd4/#加载渲染过程" class="sidebar-link">加载渲染过程</a></li><li class="sidebar-sub-header"><a href="/pages/566fd4/#子组件更新过程" class="sidebar-link">子组件更新过程</a></li><li class="sidebar-sub-header"><a href="/pages/566fd4/#父组件更新过程" class="sidebar-link">父组件更新过程</a></li><li class="sidebar-sub-header"><a href="/pages/566fd4/#销毁过程" class="sidebar-link">销毁过程</a></li></ul></li><li class="sidebar-sub-header"><a href="/pages/566fd4/#_17-vue2-x组件通信有哪些方式？" class="sidebar-link">17.Vue2.x组件通信有哪些方式？</a></li><li class="sidebar-sub-header"><a href="/pages/566fd4/#_18-ssr了解吗？" class="sidebar-link">18.SSR了解吗？</a></li><li class="sidebar-sub-header"><a href="/pages/566fd4/#_19-你都做过哪些vue的性能优化？" class="sidebar-link">19.你都做过哪些Vue的性能优化？</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/566fd4/#编码阶段" class="sidebar-link">编码阶段</a></li><li class="sidebar-sub-header"><a href="/pages/566fd4/#seo优化" class="sidebar-link">SEO优化</a></li><li class="sidebar-sub-header"><a href="/pages/566fd4/#打包优化" class="sidebar-link">打包优化</a></li><li class="sidebar-sub-header"><a href="/pages/566fd4/#用户体验" class="sidebar-link">用户体验</a></li></ul></li><li class="sidebar-sub-header"><a href="/pages/566fd4/#_20-hash路由和history路由实现原理说一下" class="sidebar-link">20.hash路由和history路由实现原理说一下</a></li></ul></li><li><a href="/pages/e7c817/" class="sidebar-link">Webpack面试题整理</a></li><li><a href="/pages/08168e/" class="sidebar-link">Web安全面试题整理</a></li><li><a href="/pages/5f1020/" class="sidebar-link">HTTP面试题整理</a></li><li><a href="/pages/3f47b4/" class="sidebar-link">这些手写代码会了吗？少年</a></li><li><a href="/pages/9cf255/" class="sidebar-link">面试前的思考</a></li></ul> </aside> <div><main class="page"> <div class="theme-vdoing-wrapper bg-style-1"><div class="articleInfo-wrap" data-v-f5f35434><div class="articleInfo" data-v-f5f35434><ul class="breadcrumbs" data-v-f5f35434><li data-v-f5f35434><a href="/" title="首页" class="iconfont icon-home router-link-active" data-v-f5f35434></a></li> <li data-v-f5f35434><a href="/categories/?category=%E9%9D%A2%E8%AF%95" title="分类" data-v-f5f35434>面试</a></li> <!----></ul> <div class="info" data-v-f5f35434><div title="作者" class="author iconfont icon-touxiang" data-v-f5f35434><a href="https://github.com/Geekhyt" target="_blank" title="作者" class="beLink" data-v-f5f35434>童欧巴</a></div> <div title="创建时间" class="date iconfont icon-riqi" data-v-f5f35434><a href="javascript:;" data-v-f5f35434>2020-03-08</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-content"></div></div></div> <h1><!---->
          Vue面试题整理
        </h1> <div class="theme-vdoing-content content__default"><p>从镜片的厚度和黄黑相见的格子衬衫我察觉到，面前坐着的这位面试官应该是来者不善。</p> <p>我像以往一样，准备花3分钟的时间进行自我介绍。在此期间，为了避免尴尬，我盯着面试官的眉毛中间，不过面试官明显对我的经历不是很感兴趣。他在1分半的时候打断了我。</p> <blockquote><p>你觉得自己最擅长的技术栈是什么？</p></blockquote> <p>Vue吧，我很喜欢尤大，最近刚发布了Vue的首部纪录片，真的很好看。</p> <h2 id="_0-那你能讲一讲mvvm吗？"><a href="#_0-那你能讲一讲mvvm吗？" class="header-anchor">#</a> 0.那你能讲一讲MVVM吗？</h2> <p>MVVM是<code>Model-View-ViewModel</code>缩写，也就是把<code>MVC</code>中的<code>Controller</code>演变成<code>ViewModel</code>。Model层代表数据模型，View代表UI组件，ViewModel是View和Model层的桥梁，数据会绑定到viewModel层并自动将数据渲染到页面中，视图变化的时候会通知viewModel层更新数据。</p> <h2 id="_1-简单说一下vue2-x响应式数据原理"><a href="#_1-简单说一下vue2-x响应式数据原理" class="header-anchor">#</a> 1.简单说一下Vue2.x响应式数据原理</h2> <p>Vue在初始化数据时，会使用<code>Object.defineProperty</code>重新定义data中的所有属性，当页面使用对应属性时，首先会进行依赖收集(收集当前组件的<code>watcher</code>)如果属性发生变化会通知相关依赖进行更新操作(<code>发布订阅</code>)。</p> <h2 id="_2-那你知道vue3-x响应式数据原理吗？"><a href="#_2-那你知道vue3-x响应式数据原理吗？" class="header-anchor">#</a> 2.那你知道Vue3.x响应式数据原理吗？</h2> <p>(还好我有看，这个难不倒我)</p> <p>Vue3.x改用<code>Proxy</code>替代Object.defineProperty。因为Proxy可以直接监听对象和数组的变化，并且有多达13种拦截方法。并且作为新标准将受到浏览器厂商重点持续的性能优化。</p> <blockquote><p>Proxy只会代理对象的第一层，那么Vue3又是怎样处理这个问题的呢？</p></blockquote> <p>（很简单啊）</p> <p>判断当前Reflect.get的返回值是否为Object，如果是则再通过<code>reactive</code>方法做代理，
这样就实现了深度观测。</p> <blockquote><p>监测数组的时候可能触发多次get/set，那么如何防止触发多次呢？</p></blockquote> <p>我们可以判断key是否为当前被代理对象target自身属性，也可以判断旧值与新值是否相等，只有满足以上两个条件之一时，才有可能执行trigger。</p> <p>面试官抬起了头。心里暗想</p> <p>(这小子还行，比上两个强，应该是多多少少看过Vue3的源码了)</p> <h2 id="_3-再说一下vue2-x中如何监测数组变化"><a href="#_3-再说一下vue2-x中如何监测数组变化" class="header-anchor">#</a> 3.再说一下vue2.x中如何监测数组变化</h2> <p>使用了函数劫持的方式，重写了数组的方法，Vue将data中的数组进行了原型链重写，指向了自己定义的数组原型方法。这样当调用数组api时，可以通知依赖更新。如果数组中包含着引用类型，会对数组中的引用类型再次递归遍历进行监控。这样就实现了监测数组变化。</p> <p>（能问到这的面试官都比较注重深度，这些常规操作要记牢）</p> <p>（原型链的细节可以参考我的另一篇专栏）</p> <p><a href="https://juejin.im/post/5d31ea79e51d457778117452" target="_blank" rel="noopener noreferrer">一文带你彻底搞懂JavaScript原型链<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h2 id="_4-nexttick知道吗，实现原理是什么？"><a href="#_4-nexttick知道吗，实现原理是什么？" class="header-anchor">#</a> 4.nextTick知道吗，实现原理是什么？</h2> <p>在下次 DOM 更新循环结束之后执行延迟回调。nextTick主要使用了宏任务和微任务。根据执行环境分别尝试采用</p> <ul><li>Promise</li> <li>MutationObserver</li> <li>setImmediate</li> <li>如果以上都不行则采用setTimeout</li></ul> <p>定义了一个异步方法，多次调用nextTick会将方法存入队列中，通过这个异步方法清空当前队列。</p> <p>（关于宏任务和微任务以及事件循环可以参考我的另两篇专栏）</p> <p>(看到这你就会发现，其实问框架最终还是考验你的原生JavaScript功底)</p> <p><a href="https://juejin.im/post/5d2036106fb9a07eb15d76e9" target="_blank" rel="noopener noreferrer">浏览器中JavaScript的事件循环<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><a href="https://juejin.im/post/5de095dd6fb9a071b5615db2" target="_blank" rel="noopener noreferrer">Node.js事件循环<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h2 id="_5-说一下vue的生命周期"><a href="#_5-说一下vue的生命周期" class="header-anchor">#</a> 5.说一下Vue的生命周期</h2> <p><code>beforeCreate</code>是new Vue()之后触发的第一个钩子，在当前阶段data、methods、computed以及watch上的数据和方法都不能被访问。</p> <p><code>created</code>在实例创建完成后发生，当前阶段已经完成了数据观测，也就是可以使用数据，更改数据，在这里更改数据不会触发updated函数。可以做一些初始数据的获取，在当前阶段无法与Dom进行交互，如果非要想，可以通过vm.$nextTick来访问Dom。</p> <p><code>beforeMount</code>发生在挂载之前，在这之前template模板已导入渲染函数编译。而当前阶段虚拟Dom已经创建完成，即将开始渲染。在此时也可以对数据进行更改，不会触发updated。</p> <p><code>mounted</code>在挂载完成后发生，在当前阶段，真实的Dom挂载完毕，数据完成双向绑定，可以访问到Dom节点，使用$refs属性对Dom进行操作。</p> <p><code>beforeUpdate</code>发生在更新之前，也就是响应式数据发生更新，虚拟dom重新渲染之前被触发，你可以在当前阶段进行更改数据，不会造成重渲染。</p> <p><code>updated</code>发生在更新完成之后，当前阶段组件Dom已完成更新。要注意的是避免在此期间更改数据，因为这可能会导致无限循环的更新。</p> <p><code>beforeDestroy</code>发生在实例销毁之前，在当前阶段实例完全可以被使用，我们可以在这时进行善后收尾工作，比如清除计时器。</p> <p><code>destroyed</code>发生在实例销毁之后，这个时候只剩下了dom空壳。组件已被拆解，数据绑定被卸除，监听被移出，子实例也统统被销毁。</p> <p>(关于Vue的生命周期详解感兴趣的也请移步我的另一篇专栏)</p> <p><a href="https://juejin.im/post/5d1b464a51882579d824af5b" target="_blank" rel="noopener noreferrer">从源码解读Vue生命周期，让面试官对你刮目相看<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h2 id="_6-你的接口请求一般放在哪个生命周期中？"><a href="#_6-你的接口请求一般放在哪个生命周期中？" class="header-anchor">#</a> 6.你的接口请求一般放在哪个生命周期中？</h2> <p>接口请求一般放在<code>mounted</code>中，但需要注意的是服务端渲染时不支持mounted，需要放到<code>created</code>中。</p> <h2 id="_7-再说一下computed和watch"><a href="#_7-再说一下computed和watch" class="header-anchor">#</a> 7.再说一下Computed和Watch</h2> <p><code>Computed</code>本质是一个具备缓存的watcher，依赖的属性发生变化就会更新视图。
适用于计算比较消耗性能的计算场景。当表达式过于复杂时，在模板中放入过多逻辑会让模板难以维护，可以将复杂的逻辑放入计算属性中处理。</p> <p><code>Watch</code>没有缓存性，更多的是观察的作用，可以监听某些数据执行回调。当我们需要深度监听对象中的属性时，可以打开<code>deep：true</code>选项，这样便会对对象中的每一项进行监听。这样会带来性能问题，优化的话可以使用<code>字符串形式</code>监听，如果没有写到组件中，不要忘记使用<code>unWatch手动注销</code>哦。</p> <h2 id="_8-说一下v-if和v-show的区别"><a href="#_8-说一下v-if和v-show的区别" class="header-anchor">#</a> 8.说一下v-if和v-show的区别</h2> <p>当条件不成立时，<code>v-if</code>不会渲染DOM元素，<code>v-show</code>操作的是样式(display)，切换当前DOM的显示和隐藏。</p> <h2 id="_9-组件中的data为什么是一个函数？"><a href="#_9-组件中的data为什么是一个函数？" class="header-anchor">#</a> 9.组件中的data为什么是一个函数？</h2> <p>一个组件被复用多次的话，也就会创建多个实例。本质上，<code>这些实例用的都是同一个构造函数</code>。如果data是对象的话，对象属于引用类型，会影响到所有的实例。所以为了保证组件不同的实例之间data不冲突，data必须是一个函数。</p> <h2 id="_10-说一下v-model的原理"><a href="#_10-说一下v-model的原理" class="header-anchor">#</a> 10.说一下v-model的原理</h2> <p><code>v-model</code>本质就是一个语法糖，可以看成是<code>value + input</code>方法的语法糖。
可以通过model属性的<code>prop</code>和<code>event</code>属性来进行自定义。原生的v-model，会根据标签的不同生成不同的事件和属性。</p> <h2 id="_11-vue事件绑定原理说一下"><a href="#_11-vue事件绑定原理说一下" class="header-anchor">#</a> 11.Vue事件绑定原理说一下</h2> <p>原生事件绑定是通过<code>addEventListener</code>绑定给真实元素的，组件事件绑定是通过Vue自定义的<code>$on</code>实现的。</p> <blockquote><p>面试官：(这小子基础还可以，接下来我得上上难度了)</p></blockquote> <h2 id="_12-vue模版编译原理知道吗，能简单说一下吗？"><a href="#_12-vue模版编译原理知道吗，能简单说一下吗？" class="header-anchor">#</a> 12.Vue模版编译原理知道吗，能简单说一下吗？</h2> <p>简单说，Vue的编译过程就是将<code>template</code>转化为<code>render</code>函数的过程。会经历以下阶段：</p> <ul><li>生成AST树</li> <li>优化</li> <li>codegen</li></ul> <p>首先解析模版，生成<code>AST语法树</code>(一种用JavaScript对象的形式来描述整个模板)。
使用大量的正则表达式对模板进行解析，遇到标签、文本的时候都会执行对应的钩子进行相关处理。</p> <p>Vue的数据是响应式的，但其实模板中并不是所有的数据都是响应式的。有一些数据首次渲染后就不会再变化，对应的DOM也不会变化。那么优化过程就是深度遍历AST树，按照相关条件对树节点进行标记。这些被标记的节点(静态节点)我们就可以<code>跳过对它们的比对</code>，对运行时的模板起到很大的优化作用。</p> <p>编译的最后一步是<code>将优化后的AST树转换为可执行的代码</code>。</p> <blockquote><p>面试官：(精神小伙啊，有点东西，难度提升，不信难不倒你)</p></blockquote> <h2 id="_13-vue2-x和vue3-x渲染器的diff算法分别说一下"><a href="#_13-vue2-x和vue3-x渲染器的diff算法分别说一下" class="header-anchor">#</a> 13.Vue2.x和Vue3.x渲染器的diff算法分别说一下</h2> <p>简单来说，diff算法有以下过程</p> <ul><li>同级比较，再比较子节点</li> <li>先判断一方有子节点一方没有子节点的情况(如果新的children没有子节点，将旧的子节点移除)</li> <li>比较都有子节点的情况(核心diff)</li> <li>递归比较子节点</li></ul> <p>正常Diff两个树的时间复杂度是<code>O(n^3)</code>，但实际情况下我们很少会进行<code>跨层级的移动DOM</code>，所以Vue将Diff进行了优化，从<code>O(n^3) -&gt; O(n)</code>，只有当新旧children都为多个子节点时才需要用核心的Diff算法进行同层级比较。</p> <p>Vue2的核心Diff算法采用了<code>双端比较</code>的算法，同时从新旧children的两端开始进行比较，借助key值找到可复用的节点，再进行相关操作。相比React的Diff算法，同样情况下可以减少移动节点次数，减少不必要的性能损耗，更加的优雅。</p> <p>Vue3.x借鉴了
<a href="https://github.com/localvoid/ivi" target="_blank" rel="noopener noreferrer">ivi<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>算法和 <a href="https://github.com/infernojs/inferno" target="_blank" rel="noopener noreferrer">inferno<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>算法</p> <p>在创建VNode时就确定其类型，以及在<code>mount/patch</code>的过程中采用<code>位运算</code>来判断一个VNode的类型，在这个基础之上再配合核心的Diff算法，使得性能上较Vue2.x有了提升。(实际的实现可以结合Vue3.x源码看。)</p> <p>该算法中还运用了<code>动态规划</code>的思想求解最长递归子序列。</p> <p>(看到这你还会发现，框架内无处不蕴藏着数据结构和算法的魅力)</p> <blockquote><p>面试官：(可以可以，看来是个苗子，不过自我介绍属实有些无聊，下一题)</p></blockquote> <p>(基操，勿6)</p> <h2 id="_14-再说一下虚拟dom以及key属性的作用"><a href="#_14-再说一下虚拟dom以及key属性的作用" class="header-anchor">#</a> 14.再说一下虚拟Dom以及key属性的作用</h2> <p>由于在浏览器中操作DOM是很昂贵的。频繁的操作DOM，会产生一定的性能问题。这就是虚拟Dom的<code>产生原因</code>。</p> <p>Vue2的Virtual DOM借鉴了开源库<code>snabbdom</code>的实现。</p> <p><code>Virtual DOM本质就是用一个原生的JS对象去描述一个DOM节点。是对真实DOM的一层抽象。</code>(也就是源码中的VNode类，它定义在src/core/vdom/vnode.js中。)</p> <p>VirtualDOM映射到真实DOM要经历VNode的create、diff、patch等阶段。</p> <p><strong>key的作用是尽可能的复用 DOM 元素。</strong></p> <p>新旧 children 中的节点只有顺序是不同的时候，最佳的操作应该是通过移动元素的位置来达到更新的目的。</p> <p>需要在新旧 children 的节点中保存映射关系，以便能够在旧 children 的节点中找到可复用的节点。key也就是children中节点的唯一标识。</p> <h2 id="_15-keep-alive了解吗"><a href="#_15-keep-alive了解吗" class="header-anchor">#</a> 15.keep-alive了解吗</h2> <p><code>keep-alive</code>可以实现组件缓存，当组件切换时不会对当前组件进行卸载。</p> <p>常用的两个属性<code>include/exclude</code>，允许组件有条件的进行缓存。</p> <p>两个生命周期<code>activated/deactivated</code>，用来得知当前组件是否处于活跃状态。</p> <p>keep-alive的中还运用了<code>LRU(Least Recently Used)</code>算法。</p> <p>（又是数据结构与算法，原来算法在前端也有这么多的应用）</p> <h2 id="_16-vue中组件生命周期调用顺序说一下"><a href="#_16-vue中组件生命周期调用顺序说一下" class="header-anchor">#</a> 16.Vue中组件生命周期调用顺序说一下</h2> <p>组件的调用顺序都是<code>先父后子</code>,渲染完成的顺序是<code>先子后父</code>。</p> <p>组件的销毁操作是<code>先父后子</code>，销毁完成的顺序是<code>先子后父</code>。</p> <h3 id="加载渲染过程"><a href="#加载渲染过程" class="header-anchor">#</a> 加载渲染过程</h3> <p><code>父beforeCreate-&gt;父created-&gt;父beforeMount-&gt;子beforeCreate-&gt;子created-&gt;子beforeMount- &gt;子mounted-&gt;父mounted</code></p> <h3 id="子组件更新过程"><a href="#子组件更新过程" class="header-anchor">#</a> 子组件更新过程</h3> <p><code>父beforeUpdate-&gt;子beforeUpdate-&gt;子updated-&gt;父updated</code></p> <h3 id="父组件更新过程"><a href="#父组件更新过程" class="header-anchor">#</a> 父组件更新过程</h3> <p><code>父 beforeUpdate -&gt; 父 updated</code></p> <h3 id="销毁过程"><a href="#销毁过程" class="header-anchor">#</a> 销毁过程</h3> <p><code>父beforeDestroy-&gt;子beforeDestroy-&gt;子destroyed-&gt;父destroyed</code></p> <h2 id="_17-vue2-x组件通信有哪些方式？"><a href="#_17-vue2-x组件通信有哪些方式？" class="header-anchor">#</a> 17.Vue2.x组件通信有哪些方式？</h2> <ul><li><p>父子组件通信</p> <p>父-&gt;子<code>props</code>，子-&gt;父 <code>$on、$emit</code></p> <p>获取父子组件实例 <code>$parent、$children</code></p> <p><code>Ref</code> 获取实例的方式调用组件的属性或者方法</p> <p><code>Provide、inject</code> 官方不推荐使用，但是写组件库时很常用</p></li> <li><p>兄弟组件通信</p> <p><code>Event Bus</code> 实现跨组件通信 <code>Vue.prototype.$bus = new Vue</code></p> <p><code>Vuex</code></p></li> <li><p>跨级组件通信</p> <p><code>Vuex</code></p> <p><code>$attrs、$listeners</code></p> <p><code>Provide、inject</code></p></li></ul> <h2 id="_18-ssr了解吗？"><a href="#_18-ssr了解吗？" class="header-anchor">#</a> 18.SSR了解吗？</h2> <p>SSR也就是服务端渲染，<code>也就是将Vue在客户端把标签渲染成HTML的工作放在服务端完成，然后再把html直接返回给客户端</code>。</p> <p>SSR有着更好的SEO、并且首屏加载速度更快等优点。不过它也有一些缺点，比如我们的开发条件会受到限制，服务器端渲染只支持<code>beforeCreate</code>和<code>created</code>两个钩子，当我们需要一些外部扩展库时需要特殊处理，服务端渲染应用程序也需要处于Node.js的运行环境。还有就是服务器会有更大的负载需求。</p> <h2 id="_19-你都做过哪些vue的性能优化？"><a href="#_19-你都做过哪些vue的性能优化？" class="header-anchor">#</a> 19.你都做过哪些Vue的性能优化？</h2> <h3 id="编码阶段"><a href="#编码阶段" class="header-anchor">#</a> 编码阶段</h3> <ul><li>尽量减少data中的数据，data中的数据都会增加getter和setter，会收集对应的watcher</li> <li>v-if和v-for不能连用</li> <li>如果需要使用v-for给每项元素绑定事件时使用事件代理</li> <li>SPA 页面采用keep-alive缓存组件</li> <li>在更多的情况下，使用v-if替代v-show</li> <li>key保证唯一</li> <li>使用路由懒加载、异步组件</li> <li>防抖、节流</li> <li>第三方模块按需导入</li> <li>长列表滚动到可视区域动态加载</li> <li>图片懒加载</li></ul> <h3 id="seo优化"><a href="#seo优化" class="header-anchor">#</a> SEO优化</h3> <ul><li>预渲染</li> <li>服务端渲染SSR</li></ul> <h3 id="打包优化"><a href="#打包优化" class="header-anchor">#</a> 打包优化</h3> <ul><li>压缩代码</li> <li>Tree Shaking/Scope Hoisting</li> <li>使用cdn加载第三方模块</li> <li>多线程打包happypack</li> <li>splitChunks抽离公共文件</li> <li>sourceMap优化</li></ul> <h3 id="用户体验"><a href="#用户体验" class="header-anchor">#</a> 用户体验</h3> <ul><li>骨架屏</li> <li>PWA</li></ul> <p>还可以使用缓存(客户端缓存、服务端缓存)优化、服务端开启gzip压缩等。</p> <p>(优化是个大工程，会涉及很多方面，这里申请另开一个专栏)</p> <h2 id="_20-hash路由和history路由实现原理说一下"><a href="#_20-hash路由和history路由实现原理说一下" class="header-anchor">#</a> 20.hash路由和history路由实现原理说一下</h2> <p><code>location.hash</code>的值实际就是URL中<code>#</code>后面的东西。</p> <p>history实际采用了HTML5中提供的API来实现，主要有<code>history.pushState()</code>和<code>history.replaceState()</code>。</p> <p>面试官拿起旁边已经凉透的咖啡，喝了一口。</p> <p>(我难道问不倒这小子了么)</p></div></div> <div class="page-edit"><!----> <div class="tags"><a href="/tags/?tag=Vue" title="标签">#Vue</a></div> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">2020/10/01, 19:10:00</span></div></div> <div class="page-nav-wapper"><div class="page-nav-centre-wrap"><!----> <a href="/pages/e7c817/" class="page-nav-centre page-nav-centre-next"><div class="tooltip">Webpack面试题整理</div></a></div> <div class="page-nav"><p class="inner"><!----> <span class="next"><a href="/pages/e7c817/">Webpack面试题整理</a>→
      </span></p></div></div></div> <div class="article-list"><div class="article-title"><a href="/archives/" class="iconfont icon-bi">最近更新</a></div> <div class="article-wrapper"><dl><dd>01</dd> <dt><a href="/pages/fa7f62/"><div>教女朋友学前端之深入理解JS引擎</div></a> <span>08-16</span></dt></dl><dl><dd>02</dd> <dt><a href="/pages/aa01e0/"><div>如何打造高效好用的终端？拿来吧你！</div></a> <span>07-14</span></dt></dl><dl><dd>03</dd> <dt><a href="/pages/c0e0d4/"><div>假如易立竞问你如何判断 JavaScript 中的数据类型？</div></a> <span>06-08</span></dt></dl> <dl><dd></dd> <dt><a href="/archives/" class="more">更多文章&gt;</a></dt></dl></div></div> </main></div> <div class="footer"><div class="icons"><a href="mailto:hungryturbo@gmail.com" title="发邮件" target="_blank" class="iconfont icon-youjian"></a><a href="https://github.com/Geekhyt" title="GitHub" target="_blank" class="iconfont icon-github"></a><a href="https://juejin.im/user/3491704662669469" title="掘金" target="_blank" class="iconfont icon-juejin"></a><a href="https://www.zhihu.com/people/huo-yi-tong-98" title="知乎" target="_blank" class="iconfont icon-zhihu"></a><a href="https://weibo.com/u/2771284557" title="微博" target="_blank" class="iconfont icon-weibo"></a><a href="https://space.bilibili.com/161753278" title="哔哩哔哩" target="_blank" class="iconfont icon-bilibili"></a></div> 
        © 2019-2021
        <span>童欧巴 | hungryturbo</span></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">跟随系统</li><li class="iconfont icon-rijianmoshi">浅色模式</li><li class="iconfont icon-yejianmoshi">深色模式</li><li class="iconfont icon-yuedu">阅读模式</li></ul></div></div> <!----></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.e6110941.js" defer></script><script src="/assets/js/2.d5df4bac.js" defer></script><script src="/assets/js/3.91f688ac.js" defer></script><script src="/assets/js/62.ad006f4a.js" defer></script>
  </body>
</html>